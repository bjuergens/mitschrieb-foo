<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="pandoc.css">
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#allgemeine-konzepte"><span class="toc-section-number">1</span> Allgemeine Konzepte</a><ul>
<li><a href="#toc"><span class="toc-section-number">1.1</span> TOC</a></li>
<li><a href="#vokabeln"><span class="toc-section-number">1.2</span> Vokabeln</a></li>
<li><a href="#dynamische-bindung"><span class="toc-section-number">1.3</span> Dynamische Bindung</a></li>
<li><a href="#subobjekte"><span class="toc-section-number">1.4</span> Subobjekte</a></li>
<li><a href="#v-table"><span class="toc-section-number">1.5</span> v-table</a></li>
<li><a href="#abschalten-dynamischer-bindung"><span class="toc-section-number">1.6</span> Abschalten dynamischer Bindung</a></li>
<li><a href="#type-casts"><span class="toc-section-number">1.7</span> Type Casts</a></li>
<li><a href="#objektbegriff"><span class="toc-section-number">1.8</span> Objektbegriff</a></li>
<li><a href="#tücken-der-dynamischen-bindung"><span class="toc-section-number">1.9</span> Tücken der dynamischen Bindung</a></li>
</ul></li>
<li><a href="#invarianten-und-sichere-vererbung"><span class="toc-section-number">2</span> Invarianten und sichere Vererbung</a><ul>
<li><a href="#toc-1"><span class="toc-section-number">2.1</span> TOC</a></li>
<li><a href="#motivation"><span class="toc-section-number">2.2</span> Motivation</a></li>
<li><a href="#verhaltenskonformanz"><span class="toc-section-number">2.3</span> Verhaltenskonformanz</a></li>
<li><a href="#weitere-verhaltensbeziehungen"><span class="toc-section-number">2.4</span> Weitere Verhaltensbeziehungen</a></li>
<li><a href="#inheritance-is-not-subtyping"><span class="toc-section-number">2.5</span> Inheritance is not Subtyping</a></li>
</ul></li>
<li><a href="#mehrfachvererbung"><span class="toc-section-number">3</span> Mehrfachvererbung</a><ul>
<li><a href="#toc-2"><span class="toc-section-number">3.1</span> TOC</a></li>
<li><a href="#mehrfachvererbung-in-c"><span class="toc-section-number">3.2</span> Mehrfachvererbung in C++</a></li>
<li><a href="#subobjektgraphen"><span class="toc-section-number">3.3</span> Subobjektgraphen</a></li>
<li><a href="#static-lookup"><span class="toc-section-number">3.4</span> Static Lookup</a></li>
<li><a href="#dynamic-lookup"><span class="toc-section-number">3.5</span> Dynamic lookup</a></li>
<li><a href="#static-lookup-vs-dynamic-lookup"><span class="toc-section-number">3.6</span> Static lookup vs Dynamic lookup</a></li>
</ul></li>
<li><a href="#implementierung-von-mehrfachvererbung"><span class="toc-section-number">4</span> Implementierung von Mehrfachvererbung</a><ul>
<li><a href="#toc-3"><span class="toc-section-number">4.1</span> TOC</a></li>
<li><a href="#c-type-casts"><span class="toc-section-number">4.2</span> C++ Type Casts</a></li>
<li><a href="#implementierung-vtables"><span class="toc-section-number">4.3</span> Implementierung vtables</a></li>
<li><a href="#z---mehrfachvererbung-in-java"><span class="toc-section-number">4.4</span> <strong>(Z)</strong> - Mehrfachvererbung in Java</a></li>
</ul></li>
<li><a href="#weitere-features-von-objektorientierung"><span class="toc-section-number">5</span> weitere features von Objektorientierung</a><ul>
<li><a href="#toc-4"><span class="toc-section-number">5.1</span> TOC</a></li>
<li><a href="#überladungen"><span class="toc-section-number">5.2</span> Überladungen</a></li>
<li><a href="#innere-klassen"><span class="toc-section-number">5.3</span> Innere Klassen</a></li>
<li><a href="#generics"><span class="toc-section-number">5.4</span> Generics</a></li>
</ul></li>
<li><a href="#tyrannei-der-dominanten-dekomposition"><span class="toc-section-number">6</span> Tyrannei der dominanten Dekomposition</a><ul>
<li><a href="#toc-5"><span class="toc-section-number">6.1</span> TOC</a></li>
<li><a href="#warum-dekomposition"><span class="toc-section-number">6.2</span> Warum Dekomposition</a></li>
<li><a href="#bisherige-arten-von-dekomposition"><span class="toc-section-number">6.3</span> bisherige Arten von Dekomposition</a></li>
<li><a href="#lösungsansätze"><span class="toc-section-number">6.4</span> Lösungsansätze</a></li>
</ul></li>
<li><a href="#programmanalyse"><span class="toc-section-number">7</span> Programmanalyse</a><ul>
<li><a href="#toc-6"><span class="toc-section-number">7.1</span> TOC</a></li>
<li><a href="#eigenschaften"><span class="toc-section-number">7.2</span> Eigenschaften</a></li>
<li><a href="#rapid-type-analysis"><span class="toc-section-number">7.3</span> Rapid Type Analysis</a></li>
<li><a href="#points-to-analyse"><span class="toc-section-number">7.4</span> Points-To-Analyse</a></li>
</ul></li>
<li><a href="#typsysteme-für-objektorientierung"><span class="toc-section-number">8</span> Typsysteme für Objektorientierung</a><ul>
<li><a href="#toc-7"><span class="toc-section-number">8.1</span> TOC</a></li>
<li><a href="#basis"><span class="toc-section-number">8.2</span> Basis</a></li>
<li><a href="#erweiterungen-des-typsystems"><span class="toc-section-number">8.3</span> Erweiterungen des Typsystems</a></li>
</ul></li>
<li><a href="#mitschrieb-foo"><span class="toc-section-number">9</span> mitschrieb-foo</a><ul>
<li><a href="#kompilierung"><span class="toc-section-number">9.1</span> Kompilierung</a></li>
<li><a href="#workflow"><span class="toc-section-number">9.2</span> Workflow</a></li>
</ul></li>
</ul>
</nav>
<h1 id="allgemeine-konzepte"><span class="header-section-number">1</span> Allgemeine Konzepte</h1>
<h2 id="toc"><span class="header-section-number">1.1</span> TOC</h2>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false}  -->
<!-- code_chunk_output -->
<ul>
<li><a href="#toc">TOC</a></li>
<li><a href="#vokabeln">Vokabeln</a></li>
<li><a href="#dynamische-bindung">Dynamische Bindung</a>
<ul>
<li><a href="#upcasts-und-dynamische-bindung">Upcasts und dynamische Bindung</a></li>
<li><a href="#this-zeiger">this-Zeiger</a></li>
</ul></li>
<li><a href="#subobjekte">Subobjekte</a></li>
<li><a href="#v-table">v-table</a></li>
<li><a href="#abschalten-dynamischer-bindung">Abschalten dynamischer Bindung</a></li>
<li><a href="#type-casts">Type Casts</a></li>
<li><a href="#objektbegriff">Objektbegriff</a></li>
<li><a href="#tücken-der-dynamischen-bindung">Tücken der dynamischen Bindung</a></li>
</ul>
<!-- /code_chunk_output -->
<h2 id="vokabeln"><span class="header-section-number">1.2</span> Vokabeln</h2>
<ul>
<li>Objekt
<ul>
<li>context abhängig, meistens = “Bezugsobjekt”</li>
</ul></li>
<li>Bezugsobjekt
<ul>
<li>= alle subobjekte</li>
<li>ist struct im Speicher</li>
<li>1 pro Instanziierung</li>
<li>Größe und relative Positionen innerhalb stehen zur compile time fest</li>
<li>Absolute Position im Speicher steht zur run time fest</li>
</ul></li>
<li>statischer Typ
<ul>
<li>Typ zur compile time</li>
</ul></li>
<li>dynamischer Typ
<ul>
<li>Typ zur run time</li>
</ul></li>
<li>up cast/down cast
<ul>
<li>ändern des statischen Types (bei C++ und Java)</li>
</ul></li>
<li>virtual
<ul>
<li>immer, wenn dem Stoustrup kein Wort eingefallen ist</li>
</ul></li>
<li>smart
<ul>
<li>immer wenn etwas einfaches kompliziert gemacht wird</li>
</ul></li>
<li>verdeckt
<ul>
<li>bei dynamisch: = überschrieben</li>
<li>bei statisch: = versteckt</li>
</ul></li>
<li>Objektlayout
<ul>
<li>Diagram den Objektes im Speicher. Mit Subobjekte. Optional mit Attributen</li>
<li><img src="assets/markdown-img-paste-20170923195638408.png" title="fig:" alt="U1 Objekt mut pointer y vom Typ U1" width="150" /></li>
</ul></li>
</ul>
<h2 id="dynamische-bindung"><span class="header-section-number">1.3</span> Dynamische Bindung</h2>
<p>Member:</p>
<ul>
<li>immer statisch</li>
</ul>
<p>Funktionen:</p>
<ul>
<li>öffentlich: immer dynamisch</li>
<li>privat: immer statisch</li>
</ul>
<p>Zugriff auf verdeckte Member:</p>
<ul>
<li>bei statischer Bindung:
<ul>
<li>upcast dann Zugriff</li>
</ul></li>
<li>bei dynamischer Bindung:
<ul>
<li>C++:
<ul>
<li><code>::</code></li>
<li>“<em>scope operator</em>”</li>
<li>in Methoden: <code>K::c()</code></li>
<li>außerhalb: <code>o.K::c()</code></li>
</ul></li>
<li>Java:
<ul>
<li><code>super</code></li>
<li>direkte Oberklasse</li>
<li>in Methoden: <code>super.c()</code></li>
<li>außerhalb: verboten</li>
</ul></li>
<li><code>super</code> und <code>::</code> schalten dynamische Bindung ab</li>
</ul></li>
</ul>
<h3 id="upcasts-und-dynamische-bindung"><span class="header-section-number">1.3.1</span> Upcasts und dynamische Bindung</h3>
<p><strong>Upcasts schalten <em>nicht</em> die dynamische Bindung ab!</strong></p>
<p>und downcasts auch nicht (vermutlich)</p>
<h3 id="this-zeiger"><span class="header-section-number">1.3.2</span> this-Zeiger</h3>
<p>ganz normaler pointer mit statischer Typ = aktuelle Klasse.</p>
<p><span class="math inline">\(\Rightarrow\)</span> es gilt dynamische Bindung</p>
<h2 id="subobjekte"><span class="header-section-number">1.4</span> Subobjekte</h2>
<p>subobjekte sind der Grund, weshalb statische Bindung geht.</p>
<ul>
<li>pro Objekt ein supobjekt pro (geerbter) Klasse</li>
<li>Subobjekt besteht aus:
<ul>
<li>vpointer (bei Einfachvererbung reicht 1 pro Gesamtobjekt)</li>
<li>eigene Member</li>
</ul></li>
<li>Objektlayout:
<ul>
<li>oben: geerbte Subobjekte</li>
<li>unten: Subobjekt der eigenen Klasse</li>
</ul></li>
<li>Zugriff über statische offsets zur compile time</li>
</ul>
<h2 id="v-table"><span class="header-section-number">1.5</span> v-table</h2>
<p>v-table sind Grund weshalb dynamische Bindung geht.</p>
<ul>
<li>global eine v-table pro Klasse</li>
<li>jedes Bezugsobjekt (bzws. jeden Subobjekt bei Mehrfachvererbung) hat einen v-pointer, der auf die v-table seiner Klasse zeigt</li>
<li>enthält Einsprungadressen der Methoden:
<ul>
<li>1 Eintrag pro Methode</li>
<li>redefinierte Methoden überschreiben geerbte Methoden</li>
</ul></li>
<li>Position in vtable wird zur compile time bestimmt</li>
<li>Position des v-pointer: immer gleich im Subobjekt (i.d.R ganz am Anfang)</li>
<li><p>Zugriff zur run time:</p>
<pre><code>load [x + OFFSET VPTR], reg0
load [reg0 + OFFSET g], reg1
call reg1</code></pre></li>
</ul>
<h2 id="abschalten-dynamischer-bindung"><span class="header-section-number">1.6</span> Abschalten dynamischer Bindung</h2>
<p>bei folgendem wird immer statisch gebunden:</p>
<ul>
<li>private methoden</li>
<li>attribute</li>
<li><code>super</code> (java only)</li>
</ul>
<p>was ist mit <code>::</code>? (z.B. <code>o.K::f()</code>) (Vorsicht: <code>((K)o).f()</code> ist was anderes)</p>
<p>In den Fällen wird bereits zur compile Zeit die Adresse der Funktion eingetragen ohne den Umweg über die v-table zu gehen.</p>
<h2 id="type-casts"><span class="header-section-number">1.7</span> Type Casts</h2>
<pre><code>class O { int a, b; }
class U extends O { int b, c; }

O x = new U()</code></pre>
<p>Durch casts wird <em>nur</em> ein anderes Subobjekt ausgewählt</p>
<figure>
<img src="assets/markdown-img-paste-2017091416083689.png" alt="1 Objekt, 2 Typen" width="500" /><figcaption>1 Objekt, 2 Typen</figcaption>
</figure>
<p>–&gt; member werden sichtbar, Methoden aber nicht.</p>
<p>down cast: unsicher, schlechter stil</p>
<h2 id="objektbegriff"><span class="header-section-number">1.8</span> Objektbegriff</h2>
<p>Ziel von Objektorientierung:</p>
<ul>
<li>Geheimnisprinzip</li>
<li>Lokalitätsprinzip</li>
</ul>
<p>Klassifikation von OO-Sprachen</p>
<ul>
<li>Typisierung
<ul>
<li>statisch: c++, java</li>
<li>dynamisch: self, smalltalk</li>
</ul></li>
<li>Methodenaufrufe
<ul>
<li>echte Klassen: c++, java</li>
<li>objektbasiert ohne Klassen: javascript</li>
</ul></li>
<li>Abstraktion
<ul>
<li>statisch Schnittstellen</li>
<li>Zugriffsrechte für Klassen</li>
</ul></li>
</ul>
<figure>
<img src="assets/markdown-img-paste-20170920155237820.png" alt="Historische Entwicklung" width="500" /><figcaption>Historische Entwicklung</figcaption>
</figure>
<h2 id="tücken-der-dynamischen-bindung"><span class="header-section-number">1.9</span> Tücken der dynamischen Bindung</h2>
<p><strong>Dynamische Bindung greift auch bei Rekursion!</strong></p>
<p>d.h. wenn man versucht mit <code>super.m()</code> eine Rekursive Methode <code>m</code> im parent aufzurufen, dann kann es sein, dass die zweite Iteration wieder in der cildklasse ist, auch wenn die erste Iteration im parent war. (Vorraussetzung: <code>m</code> wird in childklasse überschrieben)</p>
<p><strong>Dynamische Bindung im Konstruktor</strong></p>
<p>Im Funktionen, die im parent Konstrutor aufgerufen werden, können in Childklase überschrieben werden.</p>
<ul>
<li>Kontruktoren von der Childklasse mussen immer den Kontruktor vom parent aufrufen.</li>
</ul>
<h1 id="invarianten-und-sichere-vererbung"><span class="header-section-number">2</span> Invarianten und sichere Vererbung</h1>
<h2 id="toc-1"><span class="header-section-number">2.1</span> TOC</h2>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#toc">TOC</a></li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#verhaltenskonformanz">Verhaltenskonformanz</a>
<ul>
<li><a href="#vokabeln">Vokabeln</a></li>
<li><a href="#realisierung-verhaltenskonformanz">Realisierung Verhaltenskonformanz</a></li>
</ul></li>
<li><a href="#weitere-verhaltensbeziehungen">Weitere Verhaltensbeziehungen</a>
<ul>
<li><a href="#spezialisierung">Spezialisierung</a></li>
<li><a href="#verhaltenskovarianz">Verhaltenskovarianz</a></li>
<li><a href="#verhaltenskontravarianz">Verhaltenskontravarianz</a></li>
</ul></li>
<li><a href="#inheritance-is-not-subtyping">Inheritance is not Subtyping</a></li>
</ul>
<!-- /code_chunk_output -->
<h2 id="motivation"><span class="header-section-number">2.2</span> Motivation</h2>
<p><code>class U extends O</code></p>
<p><strong>Typkonformanz</strong>: Jedes U ist auch als O verwendbar, denn es hat mindestens die selben Members im O-Subobjekt</p>
<p>Problem: U kann O -Methode so umdefinieren, dass sie etwas völlig anderes macht</p>
<p>⇒ Stärkere Forderung:</p>
<p><strong>Subtyping</strong>: Klientencode funktioniert auch mit U statt O</p>
<p>Andere Namen:</p>
<ul>
<li><strong>Verhaltenskonformanz</strong></li>
<li>Klientencode-Wiederverwendung</li>
<li>Liskov’sches Substitutionsprinzip [LW94]</li>
<li>Inclusion Polymorphism</li>
</ul>
<h2 id="verhaltenskonformanz"><span class="header-section-number">2.3</span> Verhaltenskonformanz</h2>
<p>Für Klienten sichere Vererbung erfordert Verhaltenskonformanz</p>
<p>Aus Sicht des Methoden<strong>verhaltens</strong> ist jedes U -Objekt auch ein O -Objekt.</p>
<p>→ Man kann O durch U ersetzen und garantieren, dass nicht kaputt geht</p>
<p>Anwendung: Implementierung von Oberlasse oder Interface</p>
<h3 id="vokabeln-1"><span class="header-section-number">2.3.1</span> Vokabeln</h3>
<p><strong>Klasseninvariante</strong>: Wird pro Klasse definiert. Gilt vor und nach jedem Methodenaufruf.</p>
<p><strong>Precondition</strong>: Wird pro Methode definiert. Muss gelten, damit die Methode aufgerufen werden darf.</p>
<p><em>→ Das, was die Methode braucht</em></p>
<p><strong>Postcondition</strong>: Wird pro Methode definiert. Gilt nachdem die Methode durchgelaufen ist.</p>
<p><em>→ Das, was die Methode tut</em></p>
<h3 id="realisierung-verhaltenskonformanz"><span class="header-section-number">2.3.2</span> Realisierung Verhaltenskonformanz</h3>
<p>Klasseninvariante von Unterklasse <span class="math inline">\(U\)</span> ist stärker als von Oberklasse <span class="math inline">\(O\)</span>:</p>
<p><span class="math display">\[INV ( U ) ⇒ INV ( O )\]</span></p>
<p><strong>stärkere Vorbedingung in Oberklasse:</strong></p>
<p><em>→ Oberklasse verlangt mehr</em></p>
<p><span class="math display">\[PRE (O.m) ⇒ PRE (U.m)\]</span></p>
<p><strong>stärkere Nachbedingung in Unterklasse:</strong></p>
<p><em>→ Unterklasse leistet mehr</em></p>
<p><span class="math display">\[POST (U.m) ⇒ POST (O.m)\]</span></p>
<p><strong><em>→ Unterklasse verlangt weniger und leistet mehr</em></strong></p>
<figure>
<img src="assets/markdown-img-paste-20170920160746866.png" alt="alternative Darstellung" width="200" /><figcaption>alternative Darstellung</figcaption>
</figure>
<h2 id="weitere-verhaltensbeziehungen"><span class="header-section-number">2.4</span> Weitere Verhaltensbeziehungen</h2>
<h3 id="spezialisierung"><span class="header-section-number">2.4.1</span> Spezialisierung</h3>
<p>= <em>Gegenteil von Verhaltenskonformanz</em></p>
<p>Problem: Verhaltenskonformanz in der Praxis selten, weil schwierig umzusetzen</p>
<p>Häufiger: Spezialisierung. (leistet auch etwas, jedoch was ganz anderes)</p>
<figure>
<img src="assets/markdown-img-paste-20170923155316405.png" width="200" />
</figure>
<p>Anwendung: Implementierung für Spezialfälle</p>
<h3 id="verhaltenskovarianz"><span class="header-section-number">2.4.2</span> Verhaltenskovarianz</h3>
<p>Implikation in Vererbungsrichtung</p>
<figure>
<img src="assets/markdown-img-paste-20170923155454321.png" width="200" />
</figure>
<h3 id="verhaltenskontravarianz"><span class="header-section-number">2.4.3</span> Verhaltenskontravarianz</h3>
<p>Implikation entgegen Vererbungsrichtung</p>
<figure>
<img src="assets/markdown-img-paste-20170923155507840.png" width="200" />
</figure>
<h2 id="inheritance-is-not-subtyping"><span class="header-section-number">2.5</span> Inheritance is not Subtyping</h2>
<p>Inheritance → Spezialisierung</p>
<p>Subtyping → Verhaltenskonformanz</p>
<p>→ Trennung von Klassen und Typen</p>
<p>Java: Interfaces für Subtyping, Klassenvererbung für Inheritance</p>
<h1 id="mehrfachvererbung"><span class="header-section-number">3</span> Mehrfachvererbung</h1>
<figure>
<img src="assets/markdown-img-paste-20170923193841785.png" width="250" />
</figure>
<h2 id="toc-2"><span class="header-section-number">3.1</span> TOC</h2>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#toc">TOC</a></li>
<li><a href="#mehrfachvererbung-in-c">Mehrfachvererbung in C++</a>
<ul>
<li><a href="#nicht-virtuelle-vererbung-in-c">Nicht-virtuelle Vererbung in C++</a></li>
<li><a href="#virtuelle-vererbung-in-c">virtuelle Vererbung in C++</a></li>
</ul></li>
<li><a href="#subobjektgraphen">Subobjektgraphen</a>
<ul>
<li><a href="#konstruktion-von-subobjektgraphen">Konstruktion von Subobjektgraphen</a></li>
</ul></li>
<li><a href="#static-lookup">Static Lookup</a>
<ul>
<li><a href="#formale-definition">Formale Definition</a></li>
</ul></li>
<li><a href="#dynamic-lookup">Dynamic lookup</a></li>
<li><a href="#static-lookup-vs-dynamic-lookup">Static lookup vs Dynamic lookup</a></li>
</ul>
<!-- /code_chunk_output -->
<h2 id="mehrfachvererbung-in-c"><span class="header-section-number">3.2</span> Mehrfachvererbung in C++</h2>
<p>C++ erlaubt Klassen-Mehrfachvererbung</p>
<p>Beispielanwendung: GUI-Fenster mit Rand und Menüleiste</p>
<figure>
<img src="assets/markdown-img-paste-20170923193812170.png" width="300" />
</figure>
<pre><code>class Window {
    virtual int area() { ... }
    virtual void g() { ... }
    virtual void h() { ... }
};
class BW : public virtual Window {
    virtual int area() { ... }
};
class MW : public virtual Window {
    virtual void g() { ... }
};
class BMW : public BW, public MW {
    virtual void h() { ... }
};


BMW* bmw = new BMW(); // bmw ist Zeiger auf BMW −Objekt
MW* mw = bmw; // Impliziter Upcast
mw-&gt;area(); // Ruft BW: : area( ) auf !</code></pre>
<h3 id="nicht-virtuelle-vererbung-in-c"><span class="header-section-number">3.2.1</span> Nicht-virtuelle Vererbung in C++</h3>
<ul>
<li>Standardvererbungstyp</li>
<li>Durchgezogene Linie im Klassendiagramm</li>
<li><p>nur von historischer Bedeutung</p>
<pre><code>class BW : public W { ... };</code></pre></li>
</ul>
<figure>
<img src="assets/markdown-img-paste-20170923194859283.png" alt="Klassendiagramm mit nicht-virtueller Vererbung" width="200" /><figcaption>Klassendiagramm mit nicht-virtueller Vererbung</figcaption>
</figure>
<figure>
<img src="assets/markdown-img-paste-20170923194449338.png" alt="Subobjekte im Speicher. Mit Pointer bmw auf Hauptobjekt" width="300" /><figcaption>Subobjekte im Speicher. Mit Pointer <code>bmw</code> auf Hauptobjekt</figcaption>
</figure>
<h3 id="virtuelle-vererbung-in-c"><span class="header-section-number">3.2.2</span> virtuelle Vererbung in C++</h3>
<ul>
<li>Schlüsselwort <code>virtual</code></li>
<li>Gestrichelte Linie im Klassendiagramm</li>
<li>Unterklassenobjekt enthält Zeiger auf Oberklassenobjekt</li>
<li><p>in der Praxis verwendet</p>
<p>class BW : public virtual W { … };</p></li>
</ul>
<figure>
<img src="assets/markdown-img-paste-2017092319471080.png" alt="Virtuelle Vererbung im Speicher" width="300" /><figcaption>Virtuelle Vererbung im Speicher</figcaption>
</figure>
<figure>
<img src="assets/markdown-img-paste-20170923194728155.png" alt="Klassendiagramm mit virtueller Vererbung" width="150" /><figcaption>Klassendiagramm mit virtueller Vererbung</figcaption>
</figure>
<figure>
<img src="assets/markdown-img-paste-20170923194216745.png" alt="Objektlayout bei virtueller Vererbung" width="60" /><figcaption>Objektlayout bei virtueller Vererbung</figcaption>
</figure>
<h2 id="subobjektgraphen"><span class="header-section-number">3.3</span> Subobjektgraphen</h2>
<figure>
<img src="assets/markdown-img-paste-20170923195314298.png" alt="links: Klassendiagramm, mitte: Subobjektgraph, rechts: Objektlayout" width="600" /><figcaption><em>links</em>: Klassendiagramm, <em>mitte</em>: Subobjektgraph, <em>rechts</em>: Objektlayout</figcaption>
</figure>
<p>Warum: Bei nicht-virtueller Vererbung entstehen komplexe Subobjekte, die z.T Duplikate enthalten</p>
<ul>
<li>Knoten [C, C·B·A]:
<ul>
<li>Subobjekte</li>
<li>“<em>Das C B A Subobjekt eines C-Objektes</em>”</li>
</ul></li>
<li>Kanten <span class="math inline">\(S \rightarrow S&#39;\)</span> (durchgezogen)
<ul>
<li><em>default Vererbung</em></li>
<li><span class="math inline">\(S&#39;\)</span> ist direkt in <span class="math inline">\(S\)</span> enthalten</li>
</ul></li>
<li>Kanten <span class="math inline">\(S \dashrightarrow S&#39;\)</span> (gestrichelt)
<ul>
<li><em>virtuelle Vererbung</em></li>
<li><span class="math inline">\(S\)</span> hat pointer auf <span class="math inline">\(S&#39;\)</span></li>
</ul></li>
</ul>
<h3 id="konstruktion-von-subobjektgraphen"><span class="header-section-number">3.3.1</span> Konstruktion von Subobjektgraphen</h3>
<p><strong>Gegeben</strong>: Klassenhierarchie mit virtueller und nicht-virtueller Vererbung</p>
<p><strong>Gesucht</strong>: Zugehöriger Subobjektgraph</p>
<p>Definitionen:</p>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Bedeutung</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(X &lt;_N Y\)</span></td>
<td><span class="math inline">\(X\)</span> erbt <strong>direkt</strong> und <strong>nicht-virtuell</strong> von <span class="math inline">\(Y\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(X &lt;_V Y\)</span></td>
<td><span class="math inline">\(X\)</span> erbt <strong>direkt</strong> und <strong>virtuell</strong> von <span class="math inline">\(Y\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(X &lt; Y\)</span></td>
<td><span class="math inline">\(X\)</span> erbt <strong>direkt</strong> von <span class="math inline">\(Y\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(X &lt;^* Y\)</span></td>
<td><span class="math inline">\(X\)</span> erbt <strong>indirekt</strong> von <span class="math inline">\(Y\)</span>, reflexive transitive Hülle von <span class="math inline">\(&lt;\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(X \sqsubset_p Y\)</span></td>
<td>Pfad der Länge <span class="math inline">\(p\)</span> von <span class="math inline">\(X\)</span> nach <span class="math inline">\(Y\)</span>, <span class="math inline">\(\sqsubset_1\)</span> ist Kante</td>
</tr>
</tbody>
</table>
<h4 id="ermitteln-der-knoten"><span class="header-section-number">3.3.1.1</span> Ermitteln der Knoten</h4>
<ul>
<li><span class="math inline">\([X,X]\)</span> ist <em>Gesamtobjekt</em></li>
<li><span class="math inline">\([X α·X·Z]\)</span> ist Subobjekt
<ul>
<li>Wenn <span class="math inline">\([X, α·Y]\)</span> Subobjekt</li>
<li>und <span class="math inline">\(Y&lt;_N Z\)</span></li>
</ul></li>
<li><span class="math inline">\([X,Z]\)</span>
<ul>
<li>wenn <span class="math inline">\([X, α]\)</span> Subobjekt</li>
<li>und <span class="math inline">\(∃_Y:\)</span>
<ul>
<li><span class="math inline">\(X &lt;^* Y\)</span></li>
<li>und <span class="math inline">\(Y &lt;_V Z\)</span></li>
</ul></li>
</ul></li>
</ul>
<h4 id="ermitteln-der-kanten"><span class="header-section-number">3.3.1.2</span> Ermitteln der Kanten</h4>
<p><span class="math inline">\(\sqsubset_1\)</span>: Kante im Graph (sowohl getrichelt als auch durchgezogen)</p>
<ul>
<li><span class="math inline">\([ X , α] \sqsubset_1 [ X , α · Y ]\)</span>
<ul>
<li><em>durchgezogen</em></li>
</ul></li>
<li><span class="math inline">\([ X , α · Y ] \sqsubset_1 [ X , Z ]\)</span>
<ul>
<li>wenn <span class="math inline">\(Y &lt;_V Z\)</span></li>
<li><em>gestrichelt</em></li>
</ul></li>
</ul>
<h2 id="static-lookup"><span class="header-section-number">3.4</span> Static Lookup</h2>
<p><strong>Gegeben</strong>: Klasse <code>C</code> in Klassenhierarchie, Membername <code>m</code></p>
<p><strong>Gesucht</strong>: „Speziellstes“ Subobjekt eines <code>C</code>-Objekts, in dem <code>m</code> deklariert ist</p>
<p>Problem: Klasse <code>C</code> alleine reicht nicht. Man muss bei Subobjekt anfangen zu suchen.</p>
<p><code>lookup(σ,m) = ο'</code>:</p>
<ul>
<li><code>σ</code>: Ausgangssubobjekt</li>
<li><code>m</code>: gesuchte Methode</li>
<li><code>ο'</code>: gesuchtes Subobjekt</li>
<li>Beispiel: <code>lookup([C,C],x) = [C,C·B]</code></li>
</ul>
<p>Falls mehreindeutig: Wähle Dominantes Subobjekt. Falls immernoch mehreindeutig: <code>return ⊥</code></p>
<p>Dominanzrelation: Das dominante Subobjekt ist spezieller. D.h. es steht gibt im Subobjektgraphen einen Pfad vom dominanten Supobjekt zum dominiertem Subobjekt.</p>
<h3 id="formale-definition"><span class="header-section-number">3.4.1</span> Formale Definition</h3>
<p><span class="math display">\[lookup (σ, m ) = min ( Defs (σ, m ))\]</span></p>
<p>Bemerkung:</p>
<ul>
<li><span class="math inline">\(min(…)\)</span> ist das kleinste Subobjekt bzgl. <span class="math inline">\(\sqsubset\)</span></li>
<li>Historisch wurde min <span class="math inline">\((…)\)</span> auch „größtes“ Subobjekt genannt, und <span class="math inline">\(max\)</span> statt <span class="math inline">\(min\)</span> geschrieben, weil es physikatlisch am größten ist</li>
</ul>
<p>Definitionen:</p>
<ul>
<li><span class="math inline">\(σ = min ( S )\)</span>:
<ul>
<li><span class="math inline">\(σ\)</span> ist dominantes Subobjekt aus Subobjekt-Menge <span class="math inline">\(S\)</span></li>
<li>d.h. <span class="math inline">\(\exists\)</span> Pfad von <span class="math inline">\(σ\)</span> zu jedem anderen Subobjekt in <span class="math inline">\(S\)</span></li>
<li>Bsp. <span class="math inline">\(min(\{[ D , D · C · A ], [ D , D ]\}) = [ D , D ]\)</span></li>
</ul></li>
<li><span class="math inline">\(Member ( C )\)</span>:
<ul>
<li>die Menge aller in Klasse C deklarierten Member</li>
</ul></li>
<li><span class="math inline">\(ldc ([ C , α · A ]) = A\)</span>
<ul>
<li><span class="math inline">\(A\)</span> ist „least derived class“</li>
<li><span class="math inline">\(=\)</span> letzter Teil in Subobjektschreibweise: [C,C·B·<strong>A</strong>]</li>
</ul></li>
<li><span class="math inline">\(Defs (σ, m )\)</span>
<ul>
<li><span class="math inline">\(= \{ σ&#39; \sqsupseteq σ | m ∈ Member ( ldc (σ&#39;))\}\)</span></li>
<li>Menge aller erreichbaren Subobjekte, die Member <span class="math inline">\(m\)</span> enthalten</li>
</ul></li>
</ul>
<h2 id="dynamic-lookup"><span class="header-section-number">3.5</span> Dynamic lookup</h2>
<p><span class="math display">\[dynBind (σ, f ) = min ( Defs ([ mdc (σ), mdc (σ)], f ))\]</span></p>
<p>mit:</p>
<ul>
<li><span class="math inline">\(mdc ([ C , α · A ]) = C\)</span>
<ul>
<li>„most derived class“</li>
<li><span class="math inline">\(=\)</span> erster Teil in Subobjektschreibweise: [C,<strong>C</strong>·B·A]</li>
</ul></li>
</ul>
<h2 id="static-lookup-vs-dynamic-lookup"><span class="header-section-number">3.6</span> Static lookup vs Dynamic lookup</h2>
<p>Lemma</p>
<p><span class="math display">\[dynBind (σ, f ) = lookup ([ mdc (σ), mdc (σ)], f )\]</span></p>
<p><em>Dynamische Bindung ist wie statischer Lookup angewendet auf den dynamischen Typ</em></p>
<h1 id="implementierung-von-mehrfachvererbung"><span class="header-section-number">4</span> Implementierung von Mehrfachvererbung</h1>
<p>Reminder aus Abschnitt 1:</p>
<figure>
<img src="assets/markdown-img-paste-20170925162500628.png" width="100" />
</figure>
<figure>
<img src="assets/markdown-img-paste-20170925162343872.png" alt="C++-Objektlayout" width="500" /><figcaption>C++-Objektlayout</figcaption>
</figure>
<h2 id="toc-3"><span class="header-section-number">4.1</span> TOC</h2>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#toc">TOC</a></li>
<li><a href="#c-type-casts">C++ Type Casts</a>
<ul>
<li><a href="#nicht-virtuelle-mehrfachvererbung">nicht-virtuelle Mehrfachvererbung</a></li>
<li><a href="#virtuelle-mehrfachvererbung">virtuelle Mehrfachvererbung</a></li>
<li><a href="#ausnahmen">Ausnahmen</a></li>
</ul></li>
<li><a href="#implementierung-vtables">Implementierung vtables</a>
<ul>
<li><a href="#mehrfachvererbung-mit-vtables">Mehrfachvererbung mit vtables</a></li>
</ul></li>
<li><a href="#z-mehrfachvererbung-in-java"><strong>(Z)</strong> - Mehrfachvererbung in Java</a></li>
</ul>
<!-- /code_chunk_output -->
<h2 id="c-type-casts"><span class="header-section-number">4.2</span> C++ Type Casts</h2>
<ul>
<li>nicht-virtuelle Einfachvererbung ⇒ Nullcode</li>
<li>nicht-virtuelle Mehrfachvererbung ⇒ Verschiebung des Zeigers</li>
<li>virtuelle Mehrfachvererbung ⇒ Verfolgen des Subobjektzeigers</li>
</ul>
<h3 id="nicht-virtuelle-mehrfachvererbung"><span class="header-section-number">4.2.1</span> nicht-virtuelle Mehrfachvererbung</h3>
<figure>
<img src="assets/markdown-img-paste-20170925163820539.png" alt="nicht-virtuelle Mehrfachvererbung" width="200" /><figcaption>nicht-virtuelle Mehrfachvererbung</figcaption>
</figure>
<pre><code>class C : A, B { int c; };
B* pb; C* pc;

pb = pc;</code></pre>
<p>wird zu:</p>
<pre><code>pb = (B*) (((char *) pc) + delta(C, B));</code></pre>
<p><code>delta(C, B)</code></p>
<ul>
<li>Offset des <code>B</code>-Subobjekts in einem <code>C</code>-Subobjekt</li>
<li>zur compile time bekannt</li>
<li><code>delta(C, B) = sizeof(A)</code></li>
</ul>
<h3 id="virtuelle-mehrfachvererbung"><span class="header-section-number">4.2.2</span> virtuelle Mehrfachvererbung</h3>
<figure>
<img src="assets/markdown-img-paste-20170925164105393.png" alt="virtuelle Mehrfachvererbung" width="150" /><figcaption>virtuelle Mehrfachvererbung</figcaption>
</figure>
<pre><code>class C : A, virtual B { int c; };
B* pb; C* pc;

pb = pc;</code></pre>
<p>wird zu:</p>
<pre><code>pb = *((B**) (((char *) pc) + offset(B_ptr)));</code></pre>
<ul>
<li><code>offset(B_ptr)</code>
<ul>
<li>Offset des <code>B</code>-Subobjekt<strong>zeigers</strong> in <code>C</code>-Objekt</li>
<li>Frage: zur Übersetzungszeit bekannt?</li>
</ul></li>
</ul>
<h3 id="ausnahmen"><span class="header-section-number">4.2.3</span> Ausnahmen</h3>
<ul>
<li>Nullzeiger werden nicht verschoben
<ul>
<li>Zur Laufzeit: if null return null</li>
</ul></li>
</ul>
<h2 id="implementierung-vtables"><span class="header-section-number">4.3</span> Implementierung vtables</h2>
<ul>
<li>Enthält Einsprungadressen für Methoden</li>
<li>pro Klasse eine statische vtable “<em>vtbl</em>” bei Einfachvererbung</li>
<li>jedes Objekt enthält Zeiger auf vtbl seiner Klasse</li>
<li>Indizes für Methodennamen klassenhierarchieweit eindeutig
<ul>
<li>wird vom compiler vorgegeben</li>
</ul></li>
<li>beim Methodenaufruf zusätzlicher Indirektionsschritt:
<ul>
<li><code>C* pc = new C(); pc-&gt;h(42);</code> wird zu <code>(*(pc-&gt;vptr[2]))(pc, 42)</code></li>
</ul></li>
</ul>
<figure>
<img src="assets/markdown-img-paste-20170925165056907.png" alt="vtables und Klassehierarchie" width="300" /><figcaption>vtables und Klassehierarchie</figcaption>
</figure>
<h3 id="mehrfachvererbung-mit-vtables"><span class="header-section-number">4.3.1</span> Mehrfachvererbung mit vtables</h3>
<ul>
<li>eine <code>vtable</code> pro Subobjekt-Typ</li>
<li>jedes Subobjekt enthält Zeiger auf vtbl seines Subobjekt-Typs</li>
<li>jede Zeile enthält zusätzlich <code>delta</code></li>
</ul>
<p>Problem: Methoden müssen ihren statischen Typ kennen, um <code>this</code> korrekt casten zu können.</p>
<p>Lösung: pro Methode wird <code>delta</code> ebenfalls in <code>vtable</code> abgelegt. Damit kann dann beim Methodenaufruf gecastet werden.</p>
<figure>
<img src="assets/markdown-img-paste-20170926142010750.png" alt="Mehrfachvererbung mit vtables" width="500" /><figcaption>Mehrfachvererbung mit vtables</figcaption>
</figure>
<p><strong>Alternative zu Deltas: Thunks</strong></p>
<p>Statt Deltas in vtable generiert Compiler bei Bedarf weitere Methode (Thunk), die this -Pointer entsprechend verschiebt.</p>
<p>Ein Thunk ist sozusagen ein Wrapper</p>
<h2 id="z---mehrfachvererbung-in-java"><span class="header-section-number">4.4</span> <strong>(Z)</strong> - Mehrfachvererbung in Java</h2>
<p>via interfaces</p>
<p>ab javu 8: Default-Methoden. Damit können auch Methoden mehrfachvererbt werden</p>
<h1 id="weitere-features-von-objektorientierung"><span class="header-section-number">5</span> weitere features von Objektorientierung</h1>
<h2 id="toc-4"><span class="header-section-number">5.1</span> TOC</h2>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#toc">TOC</a></li>
<li><a href="#überladungen">Überladungen</a>
<ul>
<li><a href="#lookup">lookup</a></li>
<li><a href="#aufruf">aufruf</a></li>
<li><a href="#smart-pointer">Smart-Pointer</a></li>
</ul></li>
<li><a href="#innere-klassen">Innere Klassen</a>
<ul>
<li><a href="#statische-innere-klasse">statische innere Klasse:</a></li>
<li><a href="#dynamische-innere-klassen">Dynamische innere Klassen</a></li>
</ul></li>
<li><a href="#generics">Generics</a>
<ul>
<li><a href="#typschranken">Typschranken</a></li>
<li><a href="#type-erasure">Type Erasure</a></li>
<li><a href="#vererbung-bei-generischen-klassen">Vererbung bei generischen Klassen</a></li>
<li><a href="#wildcards">Wildcards</a></li>
</ul></li>
</ul>
<!-- /code_chunk_output -->
<h2 id="überladungen"><span class="header-section-number">5.2</span> Überladungen</h2>
<p>Jede überladene Variante hat eigenen vtable-Eintrag</p>
<p>Übliche Anwendung: Überladener Konstruktor</p>
<h3 id="lookup"><span class="header-section-number">5.2.1</span> lookup</h3>
<ul>
<li>Java:
<ul>
<li>static lookup direkt mit Signatur</li>
</ul></li>
<li>C++:
<ul>
<li>static lookup mit Namen und bei Mehrdeutigkeit vergleich der Signatur</li>
<li>bei mehreren Kandidaten: wähle spezifischste Methode</li>
</ul></li>
</ul>
<p>“spezifischer”: Alle parameter sind Unterklassen</p>
<p>⇒ Java findet andere Methode als c++</p>
<h3 id="aufruf"><span class="header-section-number">5.2.2</span> aufruf</h3>
<p>ganz normale Methodenaufruf mit dynamischer Bindung</p>
<p>Problem: Funktionen, die in Kindklasse gleich heißen, aber andere Signatur haben, sehen aus als würden sie uberschreiben, tun sie aber nicht</p>
<h3 id="smart-pointer"><span class="header-section-number">5.2.3</span> Smart-Pointer</h3>
<p>Realisiert durch Überladung des <code>-&gt;</code> operators</p>
<h2 id="innere-klassen"><span class="header-section-number">5.3</span> Innere Klassen</h2>
<p>Klassendefinition innerhalb einer anderen Klassendefinition</p>
<p>übliche Anwendung: Iteratoren</p>
<h3 id="statische-innere-klasse"><span class="header-section-number">5.3.1</span> statische innere Klasse:</h3>
<pre><code>* statisch
* Zugriff nur auf statische Member der Äußeren Klasse
* Äußeren Klasse kann auf nur statische Member zugreifen
* Erstellung: `new AußenKlasse.InnenKlasse()`
    * Warum?

class A {
    int x = 42;
    private static int y = B.u; // Okay
    public static class B {
        private static int u = 17; // Okay
        int z = x; // Fehler
    }
}
A.B b = new A.B();</code></pre>
<h3 id="dynamische-innere-klassen"><span class="header-section-number">5.3.2</span> Dynamische innere Klassen</h3>
<ul>
<li>dynamische innere Klasse darf auf nicht-statische Member der äußeren Klasse zugreifen, auh private</li>
<li><p>Jede Instanz von innerer Klasse hat impliziten Verweis auf Instanz der äußeren Klasse, ansprechbar über Outer.this</p>
<p>class C { private int x = 42; private static int y = private int w = 17; class D { int z = x + y; // Okay int w = C.this.w; // Okay } } C c = new C(); C.D d = c.new D();</p></li>
</ul>
<h2 id="generics"><span class="header-section-number">5.4</span> Generics</h2>
<p>Ziel: bessere Wiederverwendbarkeit in Libaries</p>
<ul>
<li>Java, C#: Bounded Polymorphism:
<ul>
<li>Parameter muss Unterklasse einer gewissen Klasse sein</li>
<li>⇒ Verfügbarkeit von Methoden kann auch in generischen Klassen statisch geprüft werden</li>
</ul></li>
<li>Eiffel, C++: Parameterklasse kann mit irgendwas instanziiert werden
<ul>
<li>⇒ generische Klasse nicht isoliert typcheckbar, nur konkrete Instanzen</li>
<li>⇒ Bibliotheken nicht statisch typprüfbar</li>
</ul></li>
</ul>
<h3 id="typschranken"><span class="header-section-number">5.4.1</span> Typschranken</h3>
<p>Ab java 1.5</p>
<p>Am Anfang von Klassen oder Methoden steht eine Typschranke und innerhalb der Klaase/Methode kann der Typ dann wie eine nermale Klaase benutzt werden.</p>
<h3 id="type-erasure"><span class="header-section-number">5.4.2</span> Type Erasure</h3>
<p>implementierung in Java</p>
<p>Zur compile time alle verwendeten Varianten von Methoden vom compiler angelegt. Im Byte cod sieht man dann nur noch die Überladungen, und nichs mehr von den generics</p>
<h3 id="vererbung-bei-generischen-klassen"><span class="header-section-number">5.4.3</span> Vererbung bei generischen Klassen</h3>
<p>Vererbung ganz normal</p>
<p>Typschranken dürfen spezieller werden</p>
<h3 id="wildcards"><span class="header-section-number">5.4.4</span> Wildcards</h3>
<p>für generics im Methodenparameter</p>
<h1 id="tyrannei-der-dominanten-dekomposition"><span class="header-section-number">6</span> Tyrannei der dominanten Dekomposition</h1>
<h2 id="toc-5"><span class="header-section-number">6.1</span> TOC</h2>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#toc">TOC</a></li>
<li><a href="#warum-dekomposition">Warum Dekomposition</a></li>
<li><a href="#bisherige-arten-von-dekomposition">bisherige Arten von Dekomposition</a></li>
<li><a href="#lösungsansätze">Lösungsansätze</a></li>
</ul>
<!-- /code_chunk_output -->
<h2 id="warum-dekomposition"><span class="header-section-number">6.2</span> Warum Dekomposition</h2>
<p>Ziel: Typsicherheit und Lokalitätsprinzip sind schwer zu veneinbaren.</p>
<p>Problem: Bei Erweiterungen in verschiedenen Hierarchien: Eine Hierarchie dominiert die andere</p>
<figure>
<img src="assets/markdown-img-paste-20170926133027613.png" alt="Man kann nur schwer erweiterbare Expsennions und Operationen haben" width="300" /><figcaption>Man kann nur schwer erweiterbare Expsennions <em>und</em> Operationen haben</figcaption>
</figure>
<h2 id="bisherige-arten-von-dekomposition"><span class="header-section-number">6.3</span> bisherige Arten von Dekomposition</h2>
<p>Objektorientierte Dekomposition:</p>
<pre><code>* Operationen als dynamisch gebundene Methoden
* Neuer Datentyp kein Problem
* Neue Operation erfordert Änderung aller Expression-Klassen
* ⇒ **Datentypen dominieren Operationen**</code></pre>
<p>Funktionale Dekomposition:</p>
<pre><code>* Operationen als Visitor-Objekte
* Neue Operation kein Problem
* Neuer Datentyp erfordert Änderung aller Visitor-Klassen
* ⇒ **Operationen dominieren Datentypen**</code></pre>
<h2 id="lösungsansätze"><span class="header-section-number">6.4</span> Lösungsansätze</h2>
<ul>
<li>Multimethoden
<ul>
<li>z.B. in MultiJava</li>
</ul></li>
<li>Traits, Mixins und abstrakte Typmember
<ul>
<li>z.B. in Scala</li>
</ul></li>
<li>Virtuelle Klassen
<ul>
<li>z.B. in Beta</li>
</ul></li>
</ul>
<h1 id="programmanalyse"><span class="header-section-number">7</span> Programmanalyse</h1>
<p>Ziel:</p>
<ul>
<li>Optimierung:
<ul>
<li>wenig Speicher</li>
<li>entfernen von dynamischer Bindung</li>
</ul></li>
<li>Verständnis &amp; debugging</li>
</ul>
<p><strong>Beispiel</strong>:</p>
<pre><code>class A { void f() { ... } }
class B extends A { void f() { ... } }
A p = new B();
p.f();</code></pre>
<p>⇒ <code>A.f()</code> wird neimals aufgerufen und kann entfernt werden</p>
<p>⇒ und <code>B::f()</code> kann statisich gebunden werden</p>
<h2 id="toc-6"><span class="header-section-number">7.1</span> TOC</h2>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#toc">TOC</a></li>
<li><a href="#eigenschaften">Eigenschaften</a>
<ul>
<li><a href="#fluss-sensitivität">Fluss-Sensitivität</a></li>
<li><a href="#kontext-sensitivität">Kontext-Sensitivität</a></li>
</ul></li>
<li><a href="#rapid-type-analysis">Rapid Type Analysis</a>
<ul>
<li><a href="#call-graph">Call Graph</a></li>
<li><a href="#umgang-mit-dynamischer-bindung">Umgang mit dynamischer Bindung</a></li>
<li><a href="#reduktion-des-call-graphs">Reduktion des Call-Graphs</a></li>
<li><a href="#rta-als-constraint-problem">RTA als Constraint-Problem</a></li>
<li><a href="#fazit">Fazit</a></li>
</ul></li>
<li><a href="#points-to-analyse">Points-To-Analyse</a>
<ul>
<li><a href="#points-to-graph">Points-To-Graph</a></li>
<li><a href="#nach-anderson">nach Anderson</a></li>
<li><a href="#nach-stengaard">nach Stengaard</a></li>
</ul></li>
</ul>
<!-- /code_chunk_output -->
<h2 id="eigenschaften"><span class="header-section-number">7.2</span> Eigenschaften</h2>
<ul>
<li>Statische Analyse: ohne Kompilat auszuführen</li>
<li>Whole-Program-Analyse: Gesamtes Programm (inklusive Klassenhierarchie) bekannt</li>
</ul>
<h3 id="fluss-sensitivität"><span class="header-section-number">7.2.1</span> Fluss-Sensitivität</h3>
<p>Flusssensitive Programmanalysen</p>
<ul>
<li>Beachten Reihenfolge der Anweisungen</li>
<li>Analyseergebnis pro Programmpunkt</li>
<li>präziser und aufwendiger als Fluss-insensitive Analysen</li>
</ul>
<p>Fluss<strong>in</strong>sensitive Programmanalysen</p>
<ul>
<li>Berechnen Analyseergebnis pro Programm</li>
<li>⇒ gleiches Ergebnis für alle Programmpunkte</li>
<li>Sind unpräziser, aber schneller</li>
<li>Ergebnis für p im Beispiel: p kann auf o 1 oder o 2 zeigen</li>
</ul>
<p>Beispiel:</p>
<pre><code>Object p = new Object(); // o 1
Object q = new Object(); // o 2
p = q;</code></pre>
<h3 id="kontext-sensitivität"><span class="header-section-number">7.2.2</span> Kontext-Sensitivität</h3>
<p>Kontextsensitive Programmanalysen</p>
<ul>
<li>Beachten den Aufrufkontext einer Methode</li>
<li>Berechnen Analyseergebnis pro Aufrufkontext und pro Methode</li>
<li>Ergebnis im Beispiel:
<ul>
<li>Bei Aufruf aus f() kann x nur auf o 1 zeigen</li>
<li>Bei Aufruf aus g() kann x nur auf o 2 zeigen</li>
</ul></li>
<li>Sind präziser und aufwendiger</li>
</ul>
<p>Kontext<strong>in</strong>sensitive Programmanalysen</p>
<ul>
<li>Ignorieren den Aufrufkontext einer Methode</li>
<li>Berechnen Analyseergebnis pro Methode</li>
<li>Ergebnis im Beispiel:
<ul>
<li>x kann auf o 1 oder o 2 zeigen</li>
</ul></li>
<li>Sind unpräziser, aber schneller</li>
</ul>
<p>Beispiel:</p>
<pre><code>Object foo(Object x) { return x; }
void f() { Object p = new Object(); /∗ o 1 ∗/ foo(p); }
void g() { Object q = new Object(); /∗ o 2 ∗/ foo(q); }</code></pre>
<h2 id="rapid-type-analysis"><span class="header-section-number">7.3</span> Rapid Type Analysis</h2>
<p>Einfach und schnell, aber wirkungsvoll</p>
<p><strong>Ziele</strong>: Entfernen toter Members, Eingrenzen dynamischer Bindung</p>
<p><strong>Idee</strong>: Wenn nie ein C-Objekt erzeugt wird, dann kann auch nie eine C-Methode aufgerufen werden! (außer von Unterklassen von C)</p>
<h3 id="call-graph"><span class="header-section-number">7.3.1</span> Call Graph</h3>
<p><strong>Knoten</strong>: Alle Methoden <code>C::m(P1, ..., Pn)</code>, inklusive main()-Methode, Konstruktoren und Überladungen</p>
<p><strong>Kanten</strong>: Kante von <code>C::f()</code> nach <code>D::g()</code> ⇔ <code>C::f()</code> hat einen Aufruf <code>d.g()</code> mit d vom statischen Typ <code>D</code></p>
<figure>
<img src="assets/markdown-img-paste-20170926171854747.png" alt="links: Beispielprogramm, rechts: zugehöriger call graph" width="500" /><figcaption><em>links</em>: Beispielprogramm, <em>rechts</em>: zugehöriger call graph</figcaption>
</figure>
<p><strong>Achtung bei dynamischer Bindung</strong>: Alle potentiellen Ziele des Aufrufs <code>d.g()</code> müssen berücksichtigt werden, also auch alle <code>E::g()</code> für alle Unterklassen <code>E</code> von <code>D</code></p>
<h3 id="umgang-mit-dynamischer-bindung"><span class="header-section-number">7.3.2</span> Umgang mit dynamischer Bindung</h3>
<p>Konservative Approximation:</p>
<p>Es wird nie ein möglicher Aufruf vergessen, aber manche Aufrufe werden fälschlich als möglich angenommen.</p>
<p>⇒ Menge der Aufrufziele ist manchmal zu groß, aber nie zu klein!</p>
<h3 id="reduktion-des-call-graphs"><span class="header-section-number">7.3.3</span> Reduktion des Call-Graphs</h3>
<p>Problem: Durch dyn. Bindung viele unnötige Kanten im Call-Graph</p>
<p>Lösung: finde Konstruktoren, die <strong>nie</strong> aufgerufen werden und entferne alle Methoden dieser Klasse</p>
<figure>
<img src="assets/markdown-img-paste-20170926172427452.png" alt="Klasse, die niemals instanziiert wird, kann entfernt werden" width="500" /><figcaption>Klasse, die niemals instanziiert wird, kann entfernt werden</figcaption>
</figure>
<p><strong>Algorithmus</strong>:</p>
<ol type="1">
<li>starte mit Call-Graph (, der dynamische Bindung berücksichtigt)</li>
<li>markiere alle Kanten zu virtuellen Methoden als <em>verboten</em></li>
<li>markiere alle Kanten <strong>von</strong> <code>main()</code> <strong>zu</strong> Konstruktoren als <em>erlaubt</em></li>
<li>while (keine neuen Kanten):
<ol start="5" type="1">
<li>Starte bei <code>main()</code> und markiere Knoten, die über <em>erlaubte</em> Kanten erreichbar sind</li>
<li>Wenn markierter Knoten Konstruktor von Klasse C ist, markiere alle Kanten als erlaubt, die die <strong>von</strong> markierten Knoten <strong>zu</strong> Methoden der VTable von C zeigen als <em>erlaubt</em></li>
</ol></li>
<li>Entferne alles, was von <code>main()</code> aus nicht über erlaubte Kanten erreichbar isr</li>
</ol>
<p><strong>Achtung:</strong> VTable von C kann auch ererbte Methoden enthalten ⇒ Methoden der Oberklasse können erlaubt werden, obwohl nie ein Oberklassenobjekt erstellt wird</p>
<p>Beispiel:</p>
<figure>
<img src="assets/markdown-img-paste-20170926173906937.png" alt="Initialisierung" width="500" /><figcaption>Initialisierung</figcaption>
</figure>
<figure>
<img src="assets/markdown-img-paste-20170926173833208.png" alt="Ergebnis" width="500" /><figcaption>Ergebnis</figcaption>
</figure>
<h3 id="rta-als-constraint-problem"><span class="header-section-number">7.3.4</span> RTA als Constraint-Problem</h3>
<p>RTA auch als Constraint-Problem formulierbar:</p>
<ul>
<li>Menge R: Menge der „lebendigen“ Methoden</li>
<li>Menge S: Menge der „lebendigen“ Klassen</li>
</ul>
<figure>
<img src="assets/markdown-img-paste-20170926174214488.png" alt="Inferenzregeln zur Bestimmung der Mengen R, S" width="500" /><figcaption>Inferenzregeln zur Bestimmung der Mengen R, S</figcaption>
</figure>
<h3 id="fazit"><span class="header-section-number">7.3.5</span> Fazit</h3>
<ul>
<li>sehr schnell
<ul>
<li>da fluss- und kontext-insensitiv</li>
<li>Overhead bei Kompilierdauer &lt; 5%</li>
</ul></li>
<li>Sehr effektiv bei Klassenbibliotheken</li>
<li>sehr ungenau:
<ul>
<li>von vieln Objekten wird <strong>nicht</strong> jede Methode aufgerufen</li>
<li>Lösung ⇒ Zeiger-Analyse (nächstes Kapitel)</li>
</ul></li>
</ul>
<h2 id="points-to-analyse"><span class="header-section-number">7.4</span> Points-To-Analyse</h2>
<p>Ziel: Bestimme für jeden Zeiger p , auf welche Objekte er zeigen könnte</p>
<p>Points-To-Menge</p>
<ul>
<li><em>= “PT-Menge”</em></li>
<li><span class="math display">\[PT (p) = \{ o_1 , o_2 , … , o_n \}\]</span></li>
<li>Menge der <strong>Objektrepräsentanten</strong> auf die <strong>dieser pointer</strong> zeigen könnte</li>
</ul>
<p>Objektrepräsentanten</p>
<ul>
<li>Problem: Potentiell werden unendlich viele Objekte erstellt (z.B. wegen <code>new</code> in Schleife)</li>
</ul>
<p>⇒ betrachte nur einen Repräsentanten von jedem <code>new</code> im Programm</p>
<p>fun fact: Exakte Points-To-Analyse ist sogar mit Repräsentantentrick unentscheidbar [Ramalingam 1994]</p>
<h3 id="points-to-graph"><span class="header-section-number">7.4.1</span> Points-To-Graph</h3>
<ul>
<li>Knoten
<ul>
<li>Objektrepräsentanten: Durchnummerieren <span class="math inline">\(o_i\)</span></li>
<li>Zeigervariable (pointer <span class="math inline">\(p\)</span>): Name der Variablen</li>
</ul></li>
<li>Kanten
<ul>
<li>Kante <span class="math inline">\(p → o_i\)</span> , wenn <span class="math inline">\(p\)</span> bei irgendeiner Ausführung des Programms auf <span class="math inline">\(o_i\)</span> zeigen <em>könnte</em></li>
</ul></li>
</ul>
<p>Triviallösung: Jeder Zeiger zeigt auf alle Objektrepräsentanten.</p>
<p>⇒ mehr Berechnungsaufwand für bessere Präzision</p>
<h3 id="nach-anderson"><span class="header-section-number">7.4.2</span> nach Anderson</h3>
<p>Idee: nich Zuweisung <span class="math inline">\(p=q\)</span> kann alles auf <span class="math inline">\(p\)</span> zeigen, was vonher auf <span class="math inline">\(q\)</span> zeugen konnte.</p>
<p><span class="math display">\[
p = q ⇒ PT (q) ⊆ PT(p)
\]</span></p>
<p>⇒ damit bekommt man ein Mengenungleichungssystem</p>
<pre><code>Object p = new Object(); // {o1} ⊆ PT(p)
Object q = p;   // PT(p) ⊆ PT(q)
Object r = q;   // PT(q) ⊆ PT(r)
p = r;  // PT ( r ) ⊆ PT(p)
Object s = new Object(); // {o2} ⊆ PT(s)
r = s;  // PT(s) ⊆ PT(r)</code></pre>
<p>beachte: <span class="math inline">\(q=p ⇒ p⊆q\)</span> (Veriablen sind vertauscht)</p>
<h4 id="lösen-des-mengenungleichungssystems"><span class="header-section-number">7.4.2.1</span> Lösen des Mengenungleichungssystems</h4>
<p>gegeben:</p>
<ul>
<li>Objektrepräsentanten <span class="math inline">\(o_1,…,o_n\)</span></li>
<li>points-to Mengen <span class="math inline">\(M_1, …, M_m\)</span></li>
<li>Ungleichungen als Liste
<ul>
<li><span class="math inline">\(M_i \subseteq N_i\)</span></li>
<li><span class="math inline">\(\{o_i\} \subseteq N_i\)</span></li>
</ul></li>
</ul>
<p>gesucht:</p>
<ul>
<li>Kleinste Mengen, die Ungleichungen erfüllen</li>
</ul>
<p>Algorithmus “<em>Fixpunktiteration</em>”:</p>
<ol type="1">
<li>(optional) Male Ungleichungen als gerichteten Graphen</li>
<li>initialisiere alle Mengen als leere Menge <span class="math inline">\(∅\)</span></li>
<li>repeat until no more change:
<ol start="3" type="1">
<li>wähle Ungleichungen (= Kante im Graphen) <span class="math inline">\(M_i \subseteq N_i\)</span></li>
<li>setze in Ergebnisliste $M_i = M_i ∪ N_i</li>
</ol></li>
</ol>
<p>beachte: Kanten müssen wiederholt werden</p>
<p>Optimierung:</p>
<ul>
<li>beginne mit Objektrepräsentanten (weil alle anderen <span class="math inline">\(=∅\)</span>)</li>
<li>Zyklen möglichst spät</li>
</ul>
<figure>
<img src="assets/markdown-img-paste-2017092823281330.png" alt="links: Ungleichungsgraph, rechts: Ergebnisliste am Anfang, unten: Beispielprogramm" width="500" /><figcaption><em>links</em>: Ungleichungsgraph, <em>rechts</em>: Ergebnisliste am Anfang, <em>unten</em>: Beispielprogramm</figcaption>
</figure>
<figure>
<img src="assets/markdown-img-paste-20170928232958772.png" alt="Ergebnisliste am Ende" width="150" /><figcaption>Ergebnisliste am Ende</figcaption>
</figure>
<p><strong>Behandlung von Attributen</strong>:</p>
<p>Attribute sind pointer</p>
<p>⇒ Berechne PT-Menge für jedes Attribut jedes Objektrepräsentanten:</p>
<p>Beispiel (Einfachvorkettete Liste)</p>
<pre><code>class C { Object data; C next; }

C c = new C(); // o1 mit PT-Mengen für o1.data, o1.next
c.data = new Object(); // o2
c.next = new C();   // o3 mit PT-Mengen für o3.data, o3.next
C c2 = c.next;</code></pre>
<figure>
<img src="assets/markdown-img-paste-20170928233324869.png" alt="PT-Graph" width="500" /><figcaption>PT-Graph</figcaption>
</figure>
<p><strong>Behandlung Funktionen</strong></p>
<p>Variablen:</p>
<p>jede Funktion mit Signatur <span class="math inline">\(R A.f(p)\)</span> verwendet neue, implizite pointer:</p>
<ul>
<li><span class="math inline">\(this_f^A\)</span></li>
<li><span class="math inline">\(ret_f^R\)</span></li>
<li><span class="math inline">\(p_f^A\)</span> (falls Name <span class="math inline">\(p\)</span> nicht eindeutig)</li>
</ul>
<p><strong>Behandlung dynamischer Bindung</strong></p>
<p>Problem: Beim Aufruf ist eine Methode ist nicht klar, welche Methode das ist, weil man das Bezugsobjekt nicht kennt</p>
<p>Lösung: Verwende jedes Bezugsobjekt in <span class="math inline">\(PT(o)\)</span></p>
<p>⇒ Wenn <span class="math inline">\(PT(o)\)</span> wächst, kommen hier Methoden dazu</p>
<h3 id="nach-stengaard"><span class="header-section-number">7.4.3</span> nach Stengaard</h3>
<p>Idee: Mache Graph ungenauer, aber dafür kleiner</p>
<p><span class="math display">\[
p = q ⇒ PT(p) = PT(q)
\]</span></p>
<p>Effiziens (mit union-find): <span class="math inline">\(O (n·α(n)), (n:=Programmgröße)\)</span></p>
<h1 id="typsysteme-für-objektorientierung"><span class="header-section-number">8</span> Typsysteme für Objektorientierung</h1>
<p><em>Anm. d. Red.</em>: Kommt zwar vermutlich in Klausur dran, aber brauche ich in meinem Programmieralltag nicht. Daher wird hier nur sehr oberflächlich darauf eingegangen.</p>
<h2 id="toc-7"><span class="header-section-number">8.1</span> TOC</h2>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#toc">TOC</a></li>
<li><a href="#basis">Basis</a></li>
<li><a href="#erweiterungen-des-typsystems">Erweiterungen des Typsystems</a></li>
</ul>
<!-- /code_chunk_output -->
<h2 id="basis"><span class="header-section-number">8.2</span> Basis</h2>
<h2 id="erweiterungen-des-typsystems"><span class="header-section-number">8.3</span> Erweiterungen des Typsystems</h2>
<p>Bisher: Objekte als Records mit Subtyping und veränderbarem Zustand</p>
<p>Erweiterungen:</p>
<ul>
<li>this -Zeiger für Methoden</li>
<li>Generische Klassen
<ul>
<li>Was ist der Typ einer generischen Klasse?</li>
<li>Kann man zwischen generischen Klassen oder ihren Instanzen Subtypen definieren?</li>
</ul></li>
<li>Rekursive Typen
<ul>
<li>Wie kann man einen Typ in sich selbst wiederverwenden?</li>
<li><code>class Node { int data; Node next; }</code></li>
</ul></li>
<li>Abstrakte Klassen
<ul>
<li>Was ist der Typ einer abstrakten Klasse?</li>
<li>Wie garantiert man, dass es eine Implementierung gibt?</li>
</ul></li>
</ul>
<h1 id="mitschrieb-foo"><span class="header-section-number">9</span> mitschrieb-foo</h1>
<p>Preview: https://rawgit.com/wotanii/mitschrieb-foo/master/build.html</p>
<p>Dies ist meine Prüfungsvorbereitung für</p>
<p><em>Fortgeschrittene Objektorientierung</em> bei <em>Prof. Snelting</em> am <em>KIT</em></p>
<p>Für Korrekturen und Hinweise bis zum 2.10.2017 bin ich dankbar. Danach interessiert es mich nicht mehr.</p>
<p>Schwerpunkt meiner Vorbereitung ist alles, was:</p>
<ul>
<li>praxisrelevant ist</li>
<li>sicher in der Klausur drann kommt</li>
</ul>
<p>Dementsprechend ziele ich auf eine 2.3, rechne jedoch mit eine 3.3 als Endnote.</p>
<p>Am Ende werde ich das hier ausrdicken und mit in tie Klausur nehmen</p>
<h2 id="kompilierung"><span class="header-section-number">9.1</span> Kompilierung</h2>
<p>Das markdown kompiliere ich mit <code>pandoc</code> mit folgenden Parametern:</p>
<p><code>-f markdown-raw_tex+tex_math_single_backslash --mathjax --smart --standalone --normalize</code></p>
<p>und das Ergebnis schaue ich mir mit Firefox (ggf. mit Addon <em>Owl - Dark Background</em>) an.</p>
<p>Bonus: dieses CSS: https://gist.github.com/killercup/5917178</p>
<h2 id="workflow"><span class="header-section-number">9.2</span> Workflow</h2>
<p>Atom Texteditor mit Plugins:</p>
<ul>
<li><a href="https://atom.io/packages/markdown-preview-enhanced">markdown-preview-enhanced</a></li>
<li><a href="https://atom.io/packages/markdown-img-paste">markdown-img-paste</a></li>
</ul>
<p>wobei ich markdown-img-paste erweitert habe, sodass eine default width von 500 gosetzt wird.</p>
<p>Wenn ich nur lesen will, benutze ich dieses Nemo-Plugin: https://github.com/wotanii/nemo-action-pandoc2ff</p>
</body>
</html>
